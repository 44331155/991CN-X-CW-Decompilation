# ROP的原理
nX-U16中，“nX”代表“No Execute”，也就是不可执行。具体来说，CPU只能执行ROM中的代码，RAM是不能当作代码来运行的。这似乎给我们计算器的编程判了死刑。但是，其实还有一种办法可以让计算器执行我们想要的代码，这就是ROP。

上一章提到过，许多函数都会用`PUSH LR`备份LR，并用`POP PC`返回，返回的地址就存在栈上。如果用我们自己的数据覆盖掉这个返回地址，就能让CPU跳转到任何我们想要的地方。ROP的基本原理就是这样的。（ROP的全称就是Return-Oriented Programming，即面向返回编程）假设我们需要CPU执行一个函数。如果跳转到函数开头的`PUSH LR`，由于此处LR的值是不可控的，所以函数执行完以后，`POP PC`就会跳到不知道什么地方去。如果跳转到`PUSH LR`下一条指令，那么函数执行完以后还要`POP PC`，但是没有对应的PUSH，所以它会从栈上再取一个值。如果跳到函数的中间，那就会从中间开始执行。如果一开始还有别的PUSH，那后面就会有对应的POP，因此函数退出时会取更多的值。只要按照这个规则把所有要执行的函数地址按顺序放到栈上，CPU就会为我们做事！

说了这么多，到底怎么覆盖栈呢？前人已经为我们准备了一个办法。在线性模式中，没有重做缓冲区。取而代之的是，每次按下等号时会把当前输入的算式复制到0xD522处，计算器会在这里解析那个算式。由于字符FD20（an）的特性，算式中的an被解析时会修改SP的值。一般来说，计算器的SP都在0xEC00以后，而an会把它放到0xD522附近。进入x an模式（x表示an前的字节数，如124an就是an前面124个字节）以后，在按下=或CALC时，负责复制输入区的函数会把LR存储到0xD4D6+x处。例如，124an中，这个地址为0xD4D6+124=0xD552=0xD522+48。也就是说，输入区从第48个字节开始的内容会被覆盖到栈上。为了方便，可以用公式76+x算出覆盖开始的地方。
# ROP的简单实例
## 示例1：自检
通过阅读源代码，我们发现（代码反编译是一件非常漫长且非常困难的工作。幸运的是，前人已经有了一些工作积累。可以在labels.txt中看到一些函数的地址，但计算器里的函数远远不止这些，更多的函数有待进一步反编译），自检函数位于22040处。这里摘录几行源代码：
```
2203E  BC AL, 2213A
22040  PUSH LR
22042  PUSH QR0
22044  MOV R1, 1
```
根据刚才讲过的规则，我们决定跳转到22042处。为了简便，在线性复数模式中进入76an（an前76个数字，=），然后输入`42 20 32`（Ai2），按=，就进入自检了。现在分析一下这段非常短的ROP。76an中，输入的第一个字节就会覆盖到栈上，因此按下=时，栈里就是`42 20 32 00`。（复制到NUL位置，你应该还记得）然后负责复制的那个函数`POP PC`，PC就变为22042。（前面讲过，PC只有2.5个字节，所以后面的1.5个字节就没了。所以说打的那个2，其实可以是任何后面一半是2的字符，只是打2最方便）跳转到22042就进入了自检函数。其实跳转到22040也是可以的，因为我们这里只有一条指令，自检函数返回到哪里我们并不在乎。
## 示例2：拼字
labels告诉我们，地址2205C可以按照二级字符表，显示出ER2指向的一行字符串，然后卡死，不返回。调用它就能实现拼字的效果，但是我们需要先让ER2指向要显示的那个字符串。幸运的是，不需要这么做！负责复制的函数会自动把ER2设置为0xD180，也就是输入区的开头。因此，只要把那个字符串打在输入区开头，然后调用2205C即可。

进入110an（不能直接运算110个数字。此处可以100数字，+，9数字，an），输入想要显示的字符串（需要按照一级字符表转换）。一行17个字符，简单起见，这里就打12345678901234567。110=76+34，因此ROP会从第34个字节开始执行。理论上应该打出`5C 20 32`，但是字符5C打不出来，怎么办呢？其实可以绕过这个限制，在字符串后面垫16个字节，然后打字符FD5C（mτ），然后再打i2。这样就凑出了一个5C。打完后按等于即可。那为什么要用110an，而不是94an呢？因为，执行2205C这个函数的时候，必定要先PUSH一些值，不能让这些值覆盖了我们的字符串，所以中间要隔开一些字节。
## 示例3：定向拼字
假设你希望显示其他地方的字符串。那就需要给ER2赋值。怎么赋值呢？我们的数据全在栈上，因此要从栈转移数据到寄存器里，自然地就想到了POP指令。我们在ROM里找到了这么一个东西：
```
08FC2  POP ER2
08FC4  POP PC
```
只要调用08FC2，就可以给ER2赋值了。还是进入110an模式。我们应该打的是`（垫34字节）C2 8F _0 __ （要显示的地址） 5C 20 _2`。C2和5C不能直接打出，所以要用@（4D）来刷。注意，用@刷字符必须要按等于，如果an位移太少，就会在这个时候触发rop，所以an位移一定要大一些。
## 示例4：双行拼字
之前用的2205C执行完就会卡死，不会返回。如果要拼两行，必定要选择一个能返回的函数，这样才有机会显示下一行。这里我们选择221AE。这个函数接受两个参数，r0=显示的行数（以像素为单位），er2=字符串的地址。为了给r0赋值，可以用这段ROM：
```
121A8  POP ER0
121AA  POP PC
```
