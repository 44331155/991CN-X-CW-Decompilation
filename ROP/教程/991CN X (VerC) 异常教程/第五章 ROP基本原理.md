# ROP的原理
nX-U16中，“nX”代表“No Execute”，也就是不可执行。具体来说，CPU只能执行ROM中的代码，RAM是不能当作代码来运行的。这似乎给我们计算器的编程判了死刑。但是，其实还有一种办法可以让计算器执行我们想要的代码，这就是ROP。

上一章提到过，许多函数都会用`PUSH LR`备份LR，并用`POP PC`返回，返回的地址就存在栈上。如果用我们自己的数据覆盖掉这个返回地址，就能让CPU跳转到任何我们想要的地方。ROP的基本原理就是这样的。（ROP的全称就是Return-Oriented Programming，即面向返回编程）假设我们需要CPU执行一个函数。如果跳转到函数开头的`PUSH LR`，由于此处LR的值是不可控的，所以函数执行完以后，`POP PC`就会跳到不知道什么地方去。如果跳转到`PUSH LR`下一条指令，那么函数执行完以后还要`POP PC`，但是没有对应的PUSH，所以它会从栈上再取一个值。如果跳到函数的中间，那就会从中间开始执行。如果一开始还有别的PUSH，那后面就会有对应的POP，因此函数退出时会取更多的值。只要按照这个规则把所有要执行的函数地址按顺序放到栈上，CPU就会为我们做事！

说了这么多，到底怎么覆盖栈呢？前人已经为我们准备了一个办法。在线性模式中，没有重做缓冲区。取而代之的是，每次按下等号时会把当前输入的算式复制到0xD522处，计算器会在这里解析那个算式。由于字符FD20（an）的特性，算式中的an被解析时会修改SP的值。一般来说，计算器的SP都在0xEC00以后，而an会把它放到0xD522附近。进入x an模式（x表示an前的字节数，如124an就是an前面124个字节）以后，在按下=或CALC时，负责复制输入区的函数会把LR存储到0xD4D6+x处。例如，124an中，这个地址为0xD4D6+124=0xD552=0xD522+48。也就是说，输入区从第48个字节开始的内容会被覆盖到栈上。为了方便，可以用公式76+x算出覆盖开始的地方。
# ROP的简单实例
## 示例1：自检
通过阅读源代码，我们发现（代码反编译是一件非常漫长且非常困难的工作。幸运的是，前人已经有了一些工作积累。可以在labels.txt中看到一些函数的地址，但计算器里的函数远远不止这些，更多的函数有待进一步反编译），自检函数位于22040处。这里摘录几行源代码：
```
2203E  BC AL, 2213A
22040  PUSH LR
22042  PUSH QR0
22044  MOV R1, 1
```
根据刚才讲过的规则，我们决定跳转到22042处。为了简便，在线性复数模式中进入76an（an前76个数字，=），然后输入`42 20 32`（Ai2），按=，就进入自检了。现在分析一下这段非常短的ROP。76an中，输入的第一个字节就会覆盖到栈上，因此按下=时，栈里就是`42 20 32 00`。（复制到NUL为止，你应该还记得）然后负责复制的那个函数`POP PC`，PC就变为22042。（前面讲过，PC只有2.5个字节，所以后面的1.5个字节就没了。所以说打的那个2，其实可以是任何后面一半是2的字符，只是打2最方便）跳转到22042就进入了自检函数。其实跳转到22040也是可以的，因为我们这里只有一条指令，自检函数返回到哪里我们并不在乎。
## 示例2：拼字
labels告诉我们，地址220FE可以按照二级字符表，在屏幕第三行显示出ER2指向的一行字符串并显示PRESS AC，然后卡死，不返回。调用它就能实现拼字的效果，但是我们需要先让ER2指向要显示的那个字符串。幸运的是，不需要手动这么做！负责复制的函数会自动把ER2设置为0xD180，也就是输入区的开头。因此，只要把那个字符串打在输入区开头，然后调用220FE即可。

进入110an（不能直接运算110个数字。此处可以100数字，+，9数字，an），输入想要显示的字符串（需要按照一级字符表转换）。一行17个字符，简单起见，这里就打12345678901234567。110=76+34，因此ROP会从第34个字节开始执行。凑满34字节，然后打出FE 20 32（Pa>kgf/in22），打完后按等于即可。那为什么要用110an，而不是94an呢？因为，220FE函数比较复杂，执行这个函数的时候，会先PUSH一些值，不能让这些值覆盖了我们的字符串，所以中间要隔开一些字节。
## 示例3：定向拼字
假设你希望显示其他地方的字符串。那就需要给ER2赋值。怎么赋值呢？我们的数据全在栈上，因此要从栈转移数据到寄存器里，自然地就想到了POP指令。我们在ROM里找到了这么一个东西：
```
08FC2  POP ER2
08FC4  POP PC
```
只要调用08FC2，就可以给ER2赋值了。还是进入110an模式。我们应该打的是`（垫34字节）C2 8F _0 __ （要显示的地址） FE 20 _2`。其中_表示什么值都可以。C2不能直接打出，所以要用@（4D）来刷。注意，用@刷字符必须要按等于，如果an位移太少，就会在这个时候触发rop，所以an位移一定要大一些。
## 示例4：双行拼字
之前用的220FE执行完就会卡死，不会返回。如果要拼两行，必定要选择一个能返回的函数，这样才有机会显示下一行。这里我们选择221AE。这个函数接受两个参数，r0=显示在第几行（以像素为单位），er2=字符串的地址。为了给r0赋值，可以用这段ROM：
```
121A8  POP ER0
121AA  POP PC
```
除此之外，还要了解221AE的一个性质：它显示完一行以后，会自动把ER2往后移到下一行那里，所以不用手动给ER2赋值。有了这些知识，就能构造ROP链了：

`A8 21 _1 __ 01 __ AE 21 _2 __ FE 20 _2`

其中，01是显示的位置，就是第1行。（第0行对应上面的指示灯。）我们发现ROP里面有一个不能直接打出的字符01。但是这里没有必要用@刷字符，因为，看字符表可以发现，字符FE01（in>cm）可以直接打出，而且01前面一个字符恰好是无关紧要的。因此我们要打的就是：

`（34字节）A8 21 _1 FE 01 __ AE 21 _2 __ FE 20 _2`

还是照例进入110an，垫34字节后输入ROP链即可。
## 示例5：按键交互
函数221C4会不断等待，直到按下SHIFT才会返回。我们就用这个函数来实现简单的按键交互。这一次先简单一点，我们希望按下SHIFT再显示拼字内容。但是注意，调用221C4后，ER2的值就没了，因此我们要手动赋值。ROP链：

`C4 21 _2 __ C2 8F _0 __ 80 D1 FE 20 _2`

输入方法和前面几个ROP一样，110an，注意C4 C2 80 D1这四个字符要用@刷。
## 示例6：加法
```
08F24  L ER10, [ER8]
08F26  ADD ER2, ER10
08F28  ST ER2, [ER8]
08F2A  POP XR8
08F2C  POP PC
```
分析这段代码，可以发现，它把ER8指向的值增加了ER2。我们接下来就要用它实现一项功能：显示字符串，按下SHIFT后让最后一个字符+1，并再次显示字符串。另外，使用加法需要给ER8赋值。我们用这个：
```
2237C  POP QR8
2237E  POP QR0
22380  POP PC
```
这是因为它可以同时更新ER2和ER8。
据此构造出ROP链：
```
A8 21 _1 __ 01 __ AE 21 _2 __ C4 21 _2 __ 7C 23
_2 __ 90 D1 __ __ __ __ __ __ __ __ 01 __ __ __
__ __ 24 8F _0 __ __ __ __ __ C2 8F _0 __ 80 D1
FE 20 _2
```
这次的ROP长了很多，我们分指令解释。第一条`A8 21 _1 __ 01 __`给R0赋值为01。然后紧接着`AE 21 _2 __`显示字符串。接下来`C4 21 _2 __`等待按SHIFT。第四条`7C 23 _2 __ 90 D1 __ __ __ __ __ __ 01 __ 01 __ __ __ __ __`把ER8赋值为0xD190，ER2赋值为01（加数）。第五条`24 8F _0 __ __ __ __ __`执行加法。注意它最后有个POP XR8，所以要给它多留4字节的栈空间。第六条`C2 8F _0 __ 80 D1`给ER2赋值为0xD180。最后`FE 20 _2`重新输出字符串。

不知你有没有发现，08F24其实执行的是双字节加法。不过，我们只会显示到D190为止，所以只要低字节+1即可，高字节变成了几我们不在乎。

最后，我们来看一个复杂案例。这是常用的注入器quickcpy++的版本之一。（注入器可以把输入的内容放到内存中，常用来注入大段ROP，因此得名。其不受输入区的200字节限制）代码分为三部分。

先分析第一部分。输入区：`FD 24 22 D3 48 A8 _2`，输入这个并按下等于，就会执行ROP。这里FD24（@）是类似于an的字符，运算它时，它会把它后面两个字节存入ER14，然后从下一个位置开始执行ROP。因此，现在ER14是0xD322。执行2A848，这里的代码是：
```
22A48  B 09D2A
```
可见跳转到了09D2A。继续追踪发现：
```
09D2A  MOV SP, ER14
09D2C  POP XR4
09D2E  POP QR8
09D30  POP PC
```
因此，它会跳转到0xD322（ER14），然后POP掉12个字节。从0xD322+12=0xD32E处开始执行接下来的ROP。如果你对之前讲的变量区比较熟悉，你会发现它刚好是变量A的地址。

接下来我们看变量区的ROP，这些ROP要以数值的形式提前存入变量区。从刚才所说的0xD32E开始：
```
4C 64 _2 __ __ __ 34 61 _1 __ 08 D5 B4 D2 6C 4B
_1 __ xx xx __ __ A0 D5 38 1D _2 __ __ __ __ __
0E 95 _2 __ 02 81 _1 __ 00 80 10 00 97 D8 80 D1
__ __ __ __ BC 73 _1 __ __ __ __ __ 0C 64 _2 __
A0 D5 34 61 _1 __ __ __ A0 D8 CE 87 _1 __ xx xx
```
一点一点分析。第一条指令是2644C。具体内容很复杂，这里只要知道它的功能是设置“模式”为“基数模式”，并且会POP两个字节，就够了。

第二条指令是16134。
```
16134  POP XR0
16136  POP PC
```
因此ER0=0xD508，ER2=0xD2B4。

第三条指令是14B6C。
```
14B6C  BL 22DC4
14B70  POP ER4
14B72  POP XR4
14B74  POP PC
```
由此可见它会调用memcpy函数，从0xD2B4这里把xx xx个字节复制到0xD508处，然后POP XR4，这里会赋值ER6=0xD5A0。注意0xD5A0对应复制前的0xD34C位置，也就是`__ __ 0E 95 _2 __`这里。这样就把整个变量区的程序复制了一份。

第四条指令是21D38。
```
21D38  MOV SP, ER6
21D3A  POP ER8
21D3C  POP PC
```
它会先跳转到0xD5A0位置，然后POP两个字节，执行下一条指令。为什么要先复制整个程序然后再跳转呢？这并非多此一举。因为接下来要调用计算模式的函数，这个函数会吃掉巨大的栈空间，因此不能在栈地址比较低的地方执行，否则就会坏掉。

第五条指令是2950E。这就是计算模式的函数，我们打开计算器的时候，选择计算模式就会进入这个函数，按“菜单”并选择模式时，会退出这个函数。注意这里已经设置模式为基数模式，所以即使调用了计算模式的函数，输入方法还是与基数模式相同，例如按下sin键不会打出sin(，而是会打出**D**。

第六条指令是18102。
```
18102  POP QR8
18104  POP XR4
18106  POP PC
```
它设置ER8为0x8000，ER10为0x0010，ER12为0xD897，ER14为0xD180，并再POP了4个字节。

第七条指令是173BC。这是一个高度复杂的函数，它可以把ER14处指向的字符串“两两拼合”。假如原来是31 32 33 34，拼合以后就是12 34。它等于把输入的数字变成了内存格式。这个函数会POP掉4个字节。

第八条指令是2640C。
```
2640C  POP ER4
2640E  POP PC
```
赋值ER4为0xD5A0。

第九条指令又是16134，赋值ER2为0xD8A0。

第十条指令是187CE。
```
187CE  MOV ER0, ER4
187D0  BL 22DC4
187D4  POP ER0
187D6  POP ER4
187D8  POP PC
```
它从0xD8A0这里复制了xx xx个字节到0xD5A0。其实0xD8A0就是刚才字符串两两拼合以后产物的位置。当前程序正在运行的位置是0xD5CC，所以正在执行的代码会被覆盖。

覆盖成什么呢？这里要输入第三部分的ROP：
```
__ __ __ __ __ 80 __ __ 2E D9 80 D1 0E 95 _2 __
BC 73 _1 __ C2 D8 __ __ C2 8F _0 __ 60 00 24 8F
_0 __ ## ## C0 __ C2 8F _0 __ 48 D9 90 FF _1 __
60 00 __ __ 34 61 _1 __ EC D5 50 __ D2 03 _2 __
34 61 _1 __ A0 D5 A0 D8 CE EB A0 D5 __ 00 00 FF
```
可以拆成以下指令：
`__ __ __ __ __ 80 __ __ 2E D9 80 D1`（这是一些数据）
`0E 95 _2 __`（如前所述，这是计算模式的函数）
`BC 73 _1 __ C2 D8 __ __`（又是那个高度复杂的函数，顺便赋值了ER8）
`C2 8F _0 __ 60 00`（赋值ER2）
`24 8F _0 __ ## ## C0 __`（加法并赋值XR8）
`C2 8F _0 __ 48 D9`（赋值ER2）
`90 FF _1 __ 60 00 __ __`（也是一种memcpy，从ER2位置复制内存到ER8位置，代码见下）
`34 61 _1 __ EC D5 50 __`（赋值ER0和R2）
`D2 03 _2 __`（把R2写入ER0，代码见下）
`34 61 _1 __ A0 D5 A0 D8`（赋值ER0和ER2）
`CE EB A0 D5 __ 00 00 FF`（也是一种memcpy，但是可以自带跳转，代码见下）

```
1FF90  MOV ER0, ER8
1FF92  BL 22DC4
1FF96  ADD SP, 2
1FF98  MOV R0, 1
1FF9A  POP ER8
1FF9C  POP PC
```
```
203D2  ST R2, [ER0]
203D4  POP PC
```
```
0EBCE  BL 22DC4
0EBD2  ADD SP, 2
0EBD4  B 09D2A
```
（咕咕咕……）
