# 【进阶篇】fx-991cnx计算器:利用ROP漏洞执行任意代码

 **Author:** [Qesole]

 **Link:** [https://zhuanlan.zhihu.com/p/620584634]

[https://www.zhihu.com/video/1636115951232946176](https://www.zhihu.com/video/1636115951232946176)## 新的内容已经更新咯，移步至第三篇：  
[Qesole：「循环/汇编器」991cnx:利用rop漏洞执行任意代码](https://zhuanlan.zhihu.com/p/657962148)## 开始前，你需要知道的：  
1. 请确保你已经阅读并理解了：

[https://zhuanlan.zhihu.com/p/618704031](https://zhuanlan.zhihu.com/p/618704031)2.以下所有操作，未经特殊说明，都是在线性、复数模式下操作

3.github地址

[https://github.com/qiufuyu123/fxesplus](https://github.com/qiufuyu123/fxesplus)## 0. 回顾  
在上一篇文章中，我们初步了解了ROP的实现原理，并做了一些小实践。

在本文中，我们将继续深入ROP，解决一些上一篇文章中留下来的问题。

在此之前，让我们回顾一下之前的内容，先来做几道简单的任务看看你有没有理解吧！

### a. 单行文字显示  
尝试编写ROP代码实现以下效果：

1. **在第二行显示文字：you**

（请读者自行思考一会儿，尝试自己实现，答案在下面）



---

答案：

首先，根据二级字符表找到you对应 **79 6F 75 —> tan( sinh-1 ln**

现在，我们来选择字符串显示函数。上文我们说到，函数2:205C可以实现只显示一行字符，不显示其他东西（例如PRESS AC），并且该函数不回返回，所以这里，我们选用这个函数。

接下来，我们想办法设置显示的行数：**第二行**

第二行，即r0寄存器被设置为 **0x1(x) ，x表示任意16进制值。**即，寄存器高八位为1（0-3对应1-4行）

查找以及字符表，发现任何 0x1(x)的字符都属于特殊字符，暂时打不出来，我们选择通过双字节字符凑出来（见上一篇文章）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-33fe16d0346a3b987cef2ac7744643ff_b.jpg)  
如图，我们选择 FE 11 这个双字节字符（即单位换算中的pc>km）

然后，选取设置r0寄存器的函数地址：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c2c6343d0f913487856186c9f5fc8444_b.jpg)  
选择函数 1:21A8 (注意，这里的效果是pop er0，到时候编写程序时注意一下，需要把剩下1个字节补全，因为er0包含了r0 和 r1 两个寄存器）

最后，让我们把这些合起来：

x(乘) e e pc>km mti i 2 0

[A8 21 21 FE] (11 FD) [5C 20 32 30](注:11 FD 就是被写入er0的值，其中11被写入r0)

然后进入线性模式—> 100+9an 模式，输入tan( sinh-1 ln i i i i i i i i i i i i i i i i i，再输入任意17字节字符，然后输入 x(乘号) e e pc>km mti(shift+7+3+x) i 2 x(变量x,为了calc清屏)

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-165d1cf71a526ce9602b414f0d6b0973_b.jpg)  
按下 CALC 按下 =

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-5158c4f27f0c5c93ccd6ab240fd6930e_b.jpg)  
### b. 连续显示两行字符  
提示：所有字符显示函数返回前， er2中的地址会自动后移



---

这里我不给出详细过程，请读者自行思考：

<34 bytes> x(乘号) e e pc>km 0 C e 2 0 x e e 0 i mti i 2 x

[A8 21 21 FE] (11 30) [AE 21 32 30] [A8 21 21 30] (21 FD) [5C 20 32 30]

（设置r0为11,即第二行，显示字符，设置r0为21，即第三行，显示字符并永不返回）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-aa5e17c1655d241272c7981d67880d5c_b.jpg)  
  


![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-6ec9ef6130eed2798e4387d71c94ad4d_b.jpg)  
##   
## 1. 不可见字符的输入  
### a. 使用场景  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-eaa1cccf73437679f3ac0ed7b2ee2343_b.jpg)  
如图，不可避免的，很多地址，例如 **0x83** 对应的字符(‘Int(‘)无法直接打出，但是，我们的ROP地址当中有相当一部分是包含特殊字符的地址。

包括在字符显示的过程中，假如你想显示字符 **e(小写字母e)** 查表会发现他对应的一级字符为 0x65(Neg符号)

所以，特殊字符的输入我们一定要解决

### b. 原理（大致）  
限于篇幅，在这里我不回过多的解释这一部分的原理，我在这里简单说明一下

在Casio计算器的内部，除了我们可见的几个变量（A B C D E F x y M）之外，还有几个隐藏变量，例如编号为 4D 的字符。

这个变量的值控制着计算器的历史页面缓冲区，也就是你每次计算完结果，按**上**键时调用的历史结果。

理论上来说，我们只要为这个寄存器赋值，那么我们就能修改历史记录缓冲区，只要修改的内容 是我们要刷出的特殊字符，那么我们就能够利用历史页面键入我们的字符。

那么，如何打出 4D 字符并为其赋值呢？

### c. 字符转换器（非常重要！！）  
众所周知，计算器内部的字符编码分为 单字节 和 双字节

在双字节字符中，FE 77 是一个特殊的存在（对应 单位换算—>第2页—> lbf/in2>kPa)

当我们利用它完成一次单位换算，例如

1 lbf/in2>kPa

31 (FE 77)

然后按下上进入历史缓冲区，会触发一个bug

此时当前的输入缓冲区会变成这样

1 | ( | 表示光标位置）

31 FE （可以看到，双字节字符被吞掉了一半，只剩下FE这个字节了）

利用这个特性，我们可以构造出一些特殊符号：

例如，我们按下数字1键，此时缓冲区内的编码为

31 FE 31

由于碰到了FE这个双字节标志，FE 31 会被当作 FE开头 双字节字符处理

通过查表，我们看到：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-f2e571de0aa13846ed790d7676818299_b.jpg)  
因此，我们可以看到屏幕上出现字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-e0c7970affca8c70c6f1eca4457d6f19_b.jpg)  

> 为了方便大家复现，我把过程写在下面（建议大家先根据刚刚的内容，自己尝试实现）  
> SHITF,8,下,2,7,左,1,=,上,左,1

如果我们键入一个双字节字符，例如这样：

31 FE FD 18 (FD 18 为Rnd# 即 SHIFT+.(小数点))

那么，计算器内部会这样解析：

31 (FE FD) 18

注意到，18被识别为了单字节字符，查表得知它是一个’@‘ 符号

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-d2639832fa92731866efb408b3bfec32_b.jpg)  
如果我们增加点操作：

31 FE FD xx ｜ 18 , 在FD和18中插入一个单字节字符（注意此时光标位置）

此时我们再按下DEL删除

31FE (FD xx) | 18 计算器会这么解析

31 FE | 18 (按下DEL后）

31 (FE 18） 我们就构造出了一个新的双字节字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-40c406c475594f522c832e571dbfd780_b.jpg)  
当然，我们也可以立刻按下一个新的单字节字符，例如数字1，应该不难猜到会发生什么：

31 (FE 31) 18

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-bd7ae9f9e5a1eab834bf1b14b47a435a_b.jpg)  

> **复现操作：**  
> **SHIFT,8,下,2,7,左,1,=,上,左,SHIFT,小数点,左左右(注意这里！！！),9,DEL**  
> **再按数字1**  
> **（至于为什么要按 左左右 来移动光标，是因为我们要在一个双字节字符中插入，但是计算器仍然把这个双字节字符当作两个单字节来显示光标，所以当按下第一次左时，光标不会动**

尝试刷取一级字符表里的16进制符号：A,B,C,E… 对应 3A 3B 3C 3D… ：

31 (FE FD) 3A (FD 3A为科学常数re,SHIFT 7 3 7）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-19f88ae227efeacd40c0c6ae430df028_b.jpg)  
移动光标，再刷一个 B 符号

31 (FE FD) (FD 3B) | 3A 

31 (FE FD) | (FD 3B) 3A

31 (FE FD) XX | (FD 3B) 3A

31 (FE FD) 3B | 3A

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c42ff52f9c35e1c356a8288a1d37e53a_b.jpg)  

> 复现操作：  
> SHIFT 8 下 2 7 左 1 = 上 左 SHIFT 7 3 7 左左右 SHIFT 7 3 8 左 9 DEL

操作得当的话，可以刷出如下 A-F 所有字符：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-36aa4dca0ba31c6f5635045528efe05e_b.jpg)  

> 复现操作：  
> SHIFT 8 下 2 7 左 1 = 上 左   
> SHIFT 7 3 C(变量c的按键) 左左右  
> SHIFT 7 3 B(变量b的按键) 左 9 DEL 左右  
> SHIFT 7 3 A(变量a的按键) 左 9 DEL 左右  
> SHIFT 7 3 9 9 左 9 DEL 左右  
> SHIFT 7 3 8 左 9 DEL 左右  
> SHIFT 7 3 7 左 9 DEL

  


我在这里总结了一些常用字符的刷法：

SHIFT 7 3 7 —> 16进制字母：A

SHIFT 7 3 8 —> … : B

….. 9 : C

….. 变量A( (-) 按键) : D

 变量B : E

 变量C : F

### e. 字符表刷字符练习  
1. 刷出 C 4 : (注意，只用字符转换器刷 C , 然后删去多余字符，再打上 4）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-3e2a76b10e69a83e1672275835d011b7_b.jpg)  

> 复现方法：  
> sft 8 下 2 7 左 1 = 上 左 sft 7 3 9 左左右 DEL DEL 右 4

2. 刷出 C 4 D 1 (先刷出C D 再补上4 1)

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-b970c9cccd0a8606b527c5b520200fbb_b.jpg)  
  




---

即然有了字符转换器，我们是不是就已经满足打出特殊字符的条件了呢？

理论上是的

但是可以发现，用这种方法打出特殊字符，实则在凑

由于并不是所有双字节字符都是可以打出的，所以实际上这种方法仍然有局限性，并且很耗时。

下面，回到之前的内容，我们利用特殊变量 4D 写入历史缓冲区，刷出特殊字符

### f. 经典·@· 刷取字符  
**注意！以下所有操作请在线性模式下进行**

构造如下表达式，利用calc按钮特性实现对4D 变量赋值（最早发现于贴吧，参考 [https://www.zhihu.com/people/fc9c9fc37de03d9fb9d2e5d7595f65db](https://www.zhihu.com/people/fc9c9fc37de03d9fb9d2e5d7595f65db) 的文章）

x : @= 10000xx xx xx xx xx 23 (xx填写字符在一级字符表中的编码）

例如

x: @ = 10000A023 可以刷出(or)符号，注意，不一定要填满5个字符编码，反正只要要刷出的**字符数小于等于4个 且 最后一个不能包含字母!（当然，不管几个字符，最后都要跟着一个'23')**

具体实现：

利用字符转换器刷出所有要用到的字母（记得按顺序），例如，这里我们刷两个(or)，需要用到两个A，我们先刷出两个A,最后再刷出@


> sft 8 下 2 7 左 1 = 上 左 sft 7 3 7 左左右 sft 7 3 7 左 9 DEL 左 右 (刷出俩A)  
> sft 7 4 8 左 9 DEL 左 右 DEL DEL (刷出4D)

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-b78ed0012433aaf970e93167049dce1a_b.jpg)  
然后：


> x(变量x) alpha 积分符号(打出`:`分隔符) 右 alpha calc 1 0 0 0 0 右 0 右 0 2 3  
> calc, = , = , AC 下

  


![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-0e0db17513199d69d0b21d2e6daf994b_b.jpg)  
  


![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-bde5cdb4a6db50be5872ff5a5089799c_b.jpg)  
### g. 刷字符练习:  
刷出一个Neg(符号：



---


> 操作：  
> sft 8 下 2 7 左 1 = 上 左 sft 7 4 8 左左右 DEL DEL   
> 打出  
> x:@=100006523  
> calc = = AC 下

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-8b945548213a6cb02996efa13b0c6c10_b.jpg)  
### h. 【实践】显示 love you  
通过查表得知，love you 编码为：

sinh-1 sinh (三次根号符号) Neg( i tan sinh-1 ln(

结合之前的方法，就可以实现啦! (留给大家自己探索)

### 【！！注意！！】  
在an异常模式下，最后一步的【AC】【下】变为：按一次【上】

## 2. 探索一些其他函数  
### a. 条纹屏幕  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-67cf969874ae19fb86fb684ef5332922_b.jpg)  


表格来自我的github页面，文章末尾有仓库地址

  
  
首先，老样子，进入110an模式

然后，利用上文所说的方法，刷出特殊字符:0xBE （应该是一个`@`符号）


> 操作： sft 8 下 2 7 左 1 = 上 左   
> sft 7 3 [变量B的按钮(°' ")] 左左右  
> sft 7 3 8 左 9 DEL   
> 左 右 sft 7 4 8 左 9 DEL   
> 左 右 DEL DEL 打出 x:@=10000BE23 calc = = 上

**注意！最后一步是按一次`上`！an异常模式下最后一步有细微区别**

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-b896211555c9bcdeefe9a95febca9cf3_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-dd2ac3fed83716a5ed9c65fa0c224192_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-4832ac0cc75cc59dfba1537ad96af1c9_b.jpg)  
然后，按下【=】

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-d3086ea1f088442d3d9831f8cc08435b_b.jpg)  
现象：

光标闪烁

按下【SHIFT】后

光标不在闪烁，死机

### b. 改变条纹样式：  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-42f8ba183fdfebaafe6f342e534a9722_b.jpg)  
非常简单。

在显示条纹之前，使用 \* e e 函数设置r1 寄存器的值即可

（至于什么值对应什么花纹，我没有特别研究。应该是和2进制点阵有关，有兴趣的读者可以自行研究）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-7a81aedbcd17f9b1be8ffa9e115d09df_b.jpg)  
### c. 按下一次按钮，改变一次花纹  
非常简单，只不过我们要刷出两个 BE

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-8bfcfadbd27e20b9cf5f3b6f4126dafb_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-fb5cad1b6f5fce6b978c9767392cff3e_b.jpg)  
这段ROP非常简单，在这里不做解释

[https://www.zhihu.com/video/1636087432205553665](https://www.zhihu.com/video/1636087432205553665)视频效果：

首先显示条纹，按下SHIFT后显示另一种样式的条纹

### d. 显示条纹，然后显示文字  
有点难度

注意一点：

**执行完显示条纹函数后，er2寄存器会被修改，因此为了显示文字，在执行完显示条纹函数后，我们需要手动为er2寄存器赋值！**

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-210c2fe9cfe0f39778ab29b34b2f03c4_b.jpg)  
在这里，选取这个函数来修改er2的值

问题：

er2的值要修改成什么？

显然，修改为输入缓冲区开头的地址。因为我们安排的要显示的字符是在头17个字节中

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-3d1a77dd2bbd55351bb76bbd8d1db15d_b.jpg)  
地址我已经整理出来了：**0xD180**

**（注意小端字节序转换，在github仓库中，我写的都是小端字节序形式，所以可以直接使用，无需转换）**

因此，有一段ROP应该是长这样的：

k 0 e 0 0 0 <80> <D1> 0 0 0 0

设置er0为 0x3030,er2 为0xD180,er4为 0x3030, er6为0x3030

由于我们只关心er2的值，所以其他的值可以随便设，这里用了'0'(0x30)

这段ROP是设置ER2寄存器的值

统计一下，我们一共需要3个特殊字符：

<BE> <80> <D1>

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-e5585c071c0abb3b97e17ff711bef646_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-11e7b741cdebf2aa3b3b4c1842db8670_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-a72bfe1194af315d6180acbeb0fc9e41_b.jpg)  
[https://www.zhihu.com/video/1636092081746636800](https://www.zhihu.com/video/1636092081746636800)### e. 显示条纹，按下按钮，显示 love you？  
与 'd' 类似，只是把显示的字符换成love you

love you 对应的一级字符是：

sinh-1 sinh 3次根号 Neg( i tan sinh-1 ln i i i i i i i i i

用到的特殊字符：

<65> <BE> <80> <D1>

不好意思，**这些字符刷不了**

**为什么？**

很简单，回到刷字符的条件：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-1e499f8f070bfb8f878f274e5b892d0a_b.png)  
显然，我们最后一个字符包含了字母（D1）！

不过可以尝试一下，如果按这个编码去刷字符，会发现当你按下 ·上· 键的时候，特殊字符并没有出现

这一块的原理限于篇幅，本文暂不讨论

### f. 如何解决这个问题  
那么，如何做到想视频中那么复杂的操作呢？（显然，视频中用到了很多的特殊字符）

我们需要一些更高级的刷字符方法

在聊这个之前，我们先来深入理解一下an字符

## 4. 深入理解堆栈溢出  
### a. an字符栈偏移的计算  
大家有没有想过一个问题：

为什么是 **110字符 + an**

而不是其它长度个字符？

要回答这个问题，我们需要从最基础的栈溢出开始讲起



---

首先，其实 110bytes + an 并不是最基本的栈溢出。

在上一篇文章中，我们提到：

触发 110bytes + an后，我们必须要填充 34bytes 的数据，之后的数据才会被覆盖进堆栈

其实，最基础的栈溢出是由 76bytes + an 触发的

也就是说，如果你输入 1 2 3 4 ...(76个数字) an ,这时已经触发了栈溢出

在这个模式下，从**输入区的第一个字节**开始，就已经覆盖到堆栈上了

也就是说，在这个模式下，我们不需要填充34个字节数据，我们可以直接写入ROP地址：

### 【演示1：76bytes an】  
首先，老方法，刷出an字符后，在前面输入76个字节内容（可以用1 2 3 4 ...来计数）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-02f63d9b963a4075ed4ef7487a82c702_b.jpg)  
然后，按下【=】，使用 2:20FE 地址（即Pa>kgf/cm2 2 0 )

注意！此处不能使用 2:205C 地址

记得为什么吗？

因为这个地址中的 5C 是靠双字节字符 mti 凑的！

当我们打出： mti i 2 0 时，16进制值是这样的：

(FD) [5C 20 32 30] <-- 真实地址是 5C 20 32 30

由于这个模式下从输入区的第一个字节开始，就会覆盖栈底，所以返回时，CPU会执行：

[FD 5C 20 32] (30)

所以地址就错了。

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-04c9b02d1ade842efb6c6eba090c2d1c_b.jpg)  
可以看到效果。

由于还是从 er2 寄存器取出字符串地址，而er2寄存器的值在执行smart\_strcpy函数后，自动被设置为输入缓冲区开始位置，所以实际上显示的字符串为：

FE 5C 32 30

对应二级字符：

'（不知道什么玩意）' '2' '0'

### 【76bytes模式的局限性？】  
很不幸，这个模式没有什么可玩的。

由于栈会被从输入区第一个字节开始的数据覆盖，这意味着一旦输入了即便是一个字符的数据，按下【=】号时，ROP就开始了。

假如我们想要先刷出一些不可见字符，在这个模式下就行不通了。

因为刷出不可见字符一定会用到字符转换器（SHIFT 8 下 2 7)

然后你一定会至少按一次【=】号（字符转换器）

但是在这个模式下，你一旦按了等于，ROP就开始执行了

不像 110bytes an 中，我们有34bytes需要填充，所以只要保证输入区不超过34bytes，我们可以随意按【=】号，因为ROP会在34bytes后被触发

### b. 构造你想要的栈偏移：  
聪明的你应该看出来了一些规律：

76 bytes 和 110 bytes 差了几个字节：

没错，**34个(110-76)**! （

发现了吗？正好对应输入缓冲区中要填充的34个字节，而ROP从**第35个**字节开始！

这就意味着，如果你想要ROP在输入缓冲区的第 n 个字节的位置开始触发

那么，你就需要构造 (76 + n)bytes an

### 【演示1：简化单行拼字】  
我们可以这样简化单行字符输出：

我们触发 93bytes an （93=76+17）

意味着ROP将在我们输入17个字符（一行）之后直接开始

首先，老样子，输入93个字符然后an字符，按下【=】号（这一步我不演示了）

然后直接开始输入你要显示的字符（查找二级字符表），然后老样子，Pa>f..... 2 0

这样。。。。。。就对了吗？



---

**等等！**

**为什么不行？为什么失败了？**

### c. 为什么偏移不对？  
如果按照刚刚所说的输入，你会发现，当你按下【=】号，理论上ROP应该执行了，应该会显示一行字符，但是为什么，计算器死机了？

是我们偏移算错了吗？

当然不是！

仔细想想，哪里错了呢？



---

错在了地址输入！

还记得在这款计算器的CPU中，**栈（地址）是2bytes对齐的吗？**

回忆一下，我们输入的内容：

[xx xx] [xx xx] [xx xx] [xx xx] [xx xx] [xx xx] [xx xx] [xx xx] [xx FE] [20 32]

(<-- 前17个字符 -->)

也就是说，此时栈POP出来的值是：[xx FE] [20 32]

自然，地址不对，计算器变死机了。

解决办法也很简单：

两个方法：

1. 删掉最后一个字符（变成地址前输入16个字符）
2. 偏移量增加1，94bytes an 模式，然后，再多输入一个字符即可

这里我选择了后者

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-b5dcca8bc747a0853b4b6aa43525aab0_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-5263f2f71dd1664f4e78c430ad8e8bc5_b.jpg)  
因此，我们注意了：

我们需要保证ROP字节前**偏移偶数个字节**，只有这样，ROP才能执行。

### 【演示（应用）：三行拼字】  
思路：

利用 2:21AE(C e 2 0) 地址实现显示字符并返回，然后利用1:21A8 （\* e e) 函数设置er0的值，选择行数

整个过程应该是这样的

x(乘号) e e in>cm(单位换算，弄出高位为0的字符) 0(补位：er1寄存器) C e 2 0 x(乘号) e e pc>cm(搞出高位为1的字符) 0 C e 2 0 Pa>kgf/cm2 2 0（这个函数默认在第三行输出字符）

实现：

首先，计算栈偏移

17(一行的字符数) \* 3 +76 = 127

显然，**127是奇数，没有2bytes对齐**

因此，我们必须输入128bytes来对齐（注意到时候输入3行字符后，要再多输入一个）

进入128bytes an 模式（100字符，'+'号，27个字符,an)

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-424c6c095ebebad95a59d1d2289b179e_b.jpg)  
输入3行字符+ROP地址

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-2e9e73c9f336f30d2c31c15cd69dea4d_b.jpg)  


注意第四行多输入了一个x字符

  
  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-46442823c3cb9b9914526032beaeb0e0_b.jpg)  
然后[CALC][=]

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-0a9c8cd3411d5656943d5dbf191ee420_b.jpg)  
## 4. 更多的特殊符号  
**【注:】以下操作请在线性模式下进行**

在【不可见字符输入】这一部分，我们讨论了最基本的特殊字符刷取的方法

但是，这个方法有很大的问题：最多刷取4**个特殊字符且有局限（最后一个字符不能包含字母编码）**

同样的，关于刷特殊字符的方法具有一个很复杂的原理，限于篇幅，本文同样暂不讨论。本文重心仍然在ROP编程方面，读者有兴趣的话，有时间我再写一篇关于字符的原理

这里，各位只需要掌握方法即可：

### a. 公式  
F. xx xx xx xx xx yy xx x10 xx (后8个字符)

`@`= 1.0000 xx xx xx yy xx x10 xx (前6个字符)

 \*注意：标注yy的地方，不能含16进制的字母，并且，14个字符必须打满!

利用这两个公式，可以刷出 6+8=14个特殊字符

### b. 用法  
首先，确定要刷的后8个字符是什么

例如：这里我们刷8个Neg( (0x65)

那么，我们先利用字符转换器刷出 'F'(16进制符号F，不是变量F） ，再构造：

F.65 65 65 65 65 65 65 x10 65

然后按 `STO` `X` （变量x)

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-175792c48a1fb4680ad0d57d3fc33598_b.jpg)  
然后【AC】

接着，确定前6个要刷的字符是什么，我们刷几个2 （0x32)

那么，这个过程和之前传统刷`@` 类似，构造：

@ = 1.00003232323232x1032

然后，构造：


> x in>cm:  
> x:  
> x in>cm:  
> @ = ......

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-3e844ce061689d88692e9d0544dc5f9c_b.jpg)  
  


![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-9dbd641eb8805ff4c3b13cc4bbf99183_b.jpg)  
  


然后，【CALC】【=】【=】【=】【=】【AC】【下】

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-f35ec4e12646fc5bdd81ebdde85eb4b0_b.jpg)  
然后：（重要！！！）

光标移到最后，删除一个空格字符和一个 x 字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-cc77b926485e9f0fe8528a058650d256_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-dce64df00045e427adf8f258a13c7617_b.jpg)  
然后，光标移到中间，删除一个空格字符,**然后再删除**一个@ 字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-58203fa0ac89905654b000c301fff4a2_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-cfc473db9875751f5f0f45afd7e24f7a_b.jpg)  
（注意！顺序不要错，不然字符显示会错位，很不好操作！）

于是，你就得到了14个特殊字符！

### c. 练习  
请刷出这几个特殊字符：

<80> <D1> <C4> <90> <D1> <BE>



---

首先,构造后8个字符：

F. 80D1C490D13232 x10 32

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-d7d75c423acab5086770fdd2e1aee0d5_b.jpg)  
然后，构造前6个:

@ = 1.000032323232BE x10 32

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-883cf26bf23116b590aa69836a0b3aa1_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-461d59d411cfbb5e2fd721f5d5575423_b.jpg)  
老样子，CALC, 4次=，AC，下

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-bdb514ed3d3c9bf7b2551dd002a05488_b.jpg)  
一系列删除之后：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-bebc482eef1001ffd268adef73616be8_b.jpg)  
### d. 注意,只有特定模式下可以使用  
这种刷字符的方式，无法在110an模式下使用！

现象：对x赋值会直接卡死

不过，在栈偏移相对大一些的特点情况下，可以使用

例如，最经典的场景：

100数字，+号，9数字，+号，13数字，an符号 (124an模式）

首先，进入这个模式。不难，就比传统的110an多了几步，按照上面的方式敲一遍就可以了

然后使用此方法刷取字符

**注意！最后一步的【AC】【下】 一定要变成：按一次【上】**

我们就可以刷取了

## 5. 高阶ROP（多种特殊字符函数）  
现在，让我们完成之前遗留的任务：

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-8b40a7b20a065e853848e10b56153963_b.png)  
首先，列出需要刷取的字符：

<65> <BE> <80> <D1>

我们将他们全部放在后8个字符中刷取

0.进入124an模式（100数字，+号，9数字，+号，13数字，an符号,【=】)

1.构造：

F. 65 BE 80 D1 32 32 32 x10 32

STO x

2. 构造：

@ = 1.00003232323232 x10 32

calc , [=]\*4 , 上 

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-5add77c8232a0da0475bc131afdd9fd1_b.jpg)  
删去多余字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-106aa7dd559c6467b6fbe299adf5e3bf_b.jpg)  
删去用于补位的'2'

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-10308d212fa53ddc50d0683e160c742d_b.jpg)  
构造love you 字符

填充17字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-6968d1e0e0d8e51633e59b7ec91bc7bc_b.jpg)  
由于这个模式在110an基础上，ROP位置后移了14字节，所以还要补上14字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-537362f54e433ce8f5a6ab9f1745fb79_b.jpg)  
构造ROP：

显示条纹且等待SHIFT输入，设置ER2的值，显示字符

（注意，符号' k '是工程符号里的K，打法：OPTN 3 6）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-40ea71d6fa78321730c90012f2f1cb7b_b.jpg)  
完成！

[https://www.zhihu.com/video/1636106728273166337](https://www.zhihu.com/video/1636106728273166337)## 6. 实现开头视频的效果(有视频教程）  
不难发现，距离开头视频只差最后一步：

再次检测按键按下，再次显示一行字

首先，无论何时，只要涉及了按键检测，ER2寄存器必须重新手动赋值

我们来计算一下：

第一次赋值，ER2被手动设为了0xD180

那么，假如说，我们在输入区，把第二行字紧挨着第一行字的那17个字符打出来

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-4741b63735653f11f1f157b7c876384c_b.jpg)  
注意，篮色框标注第二行文字存放的地方

显然，这一段数据的开头的地址是多少呢？

0xD180 + 17 ==> 0xD191

好了，我们得到了地址

理一下思路：

首先，显示条纹并等待输入，然后设置ER2寄存器的值为0xD180(同时设置R0寄存器选择行数)，然后利用Ce20显示字符，接着，等待按下SHIFT，然后设置ER2寄存器的值为0xD191(同时设置R0寄存器选择下一行)，然后利用mti i 2 0 显示字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-16b0e5fa7fffaeae72537b7b06c44aca_b.png)  
由此，写出一下ROP：

@(<BE>) e 2 0 k 0 e pc>km(第二行) @(80) >t(D1) 0 0 0 0 C e 2 0 @(<C4>) e 2 0 k 0 e 0 i i Identity((91) >t(D1) 0 0 0 mti i 2 0

还要字符编码：

sinh-1 sinh 3次根号 Neg( (<65>) i tan sinh-1 ln i i i i i i i i i --> love you

E(变量E) sinh-1 e^( Neg( 3此根号 Neg( e^( i i i i i i i i i i --> Forever

提取用到的特殊字符

<65> <65> <65> <BE> <80> <D1> <C4> <91> <D1> 一共9个

老样子，先进124an模式

排列一下：

构造后8个字符：

F.80D1C491D13232x1032

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-f348b40de7fb7e06626cfa26e845864d_b.jpg)  
前6个字符

@ = 1. 00006565656565BE x10 32 (注意，BE的位置不能再它前面的65那个位置上，具体看之前讲到的位置限制问题）

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-565564b50dd6f515f46b4c50eaf1ad41_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c01b72d46131f0d723eee9444692cb17_b.jpg)  
老样子，CALC,4下【=】，【上】

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-8cc05f57411d2427b487917a006d57ba_b.jpg)  
删除红框内字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-d7095b8d6b4cf5ebdfbaad5a1784a917_b.jpg)  
  


删除多打的一个Neg(

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-9b4751938ac1c8016748b3815ed1836b_b.jpg)  
拼出第一段：`love you` 

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-af4c9661355547b8018619b26f221d95_b.jpg)  
拼出第二段：`Forever`

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-02be32a11a23f7f1bf01a490bbeeb0b5_b.jpg)  
填充14个字符

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-92f1ae358661663bd28f48da194ac48d_b.jpg)  
构造ROP

![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-44fc921d5b72bcbfdced2529039c13ed_b.jpg)  
![]((20240419)进阶篇fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-a9ab932b1aa157e846dfb02a295f65b6_b.jpg)  
CALC,【=】

[https://www.zhihu.com/video/1636112695039721472](https://www.zhihu.com/video/1636112695039721472)

---

## 完整视频教程（如果看不懂上面的过程，可以看这个）  
由于拍摄比较麻烦，出现了一些失误

[https://www.zhihu.com/video/1636115253342724097](https://www.zhihu.com/video/1636115253342724097)  




---

github仓库

[GitHub - qiufuyu123/fxesplus: fx-991cnx逆向工程工具/整理](https://github.com/qiufuyu123/fxesplus)