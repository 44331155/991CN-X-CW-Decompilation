# fx-991cnx计算器:利用ROP漏洞执行任意代码

 **Author:** [Qesole]

 **Link:** [https://zhuanlan.zhihu.com/p/618704031]

[https://www.zhihu.com/video/1625938290124718080](https://www.zhihu.com/video/1625938290124718080)## 这个视频实现的效果：  
## 显示条纹屏幕，等待用户按下shift，显示一行文字，等待用户再次按下shift，再显示一行文字。  
**新文章来啦：**

  


[Qesole：【进阶篇】fx-991cnx计算器:利用ROP漏洞执行任意代码](https://zhuanlan.zhihu.com/p/620584634)[Qesole：「循环/汇编器」991cnx:利用rop漏洞执行任意代码](https://zhuanlan.zhihu.com/p/657962148)

---

## 0. 开始阅读前，你需要了解的：  
### a. 堆栈基础知识和一点点汇编:  
CASIO Classwiz系列计算器采用的是nX-u8系列的处理器芯片和指令集，汇编代码简单、易读，计算器本身没有暴露编程接口，是一台简单的函数机。

因此，如果一定想要对此计算机进行编程，我们必须利用一些特殊的方法，即ROP(Return Oriented Programing)，面向返回编程。这是一种逆向破解中常用的方法，原理是利用程序自身的漏洞，劫持PC（程序计数器，存储将要执行的下一条指令）寄存器，让CPU强行跳转到一个函数地址，然后修改堆栈，让该函数返回时返回到我们准备好的另一个地址。如果我们安排好堆栈的空间，让程序一级一级跳转下去，形成一条链（ROP链），便可以实现简单的编程的效果。

### b. 堆栈、寄存器、ROP简介:  
再了解ROP机制前，先来看看什么是堆栈：

先来看一个场景：


> 函数A要调用函数B，然后函数B返回到函数A继续执行，这是如何实现的？

如图，第一步，肯定是直接跳转到那个函数的开始的地址，即JMP指令，这条指令可以直接设置PC（指示CPU下一条指令的位置）指针，这样，下一个指令周期CPU就会从新的地址（PROCEDURE B）开始执行。

当然，如果直接这么操作，会有问题——程序无法返回了。因此，解决方法便是在JMP到新的位置前，**保留下调用指令的下一条指令的地址，也就是函数调用完，应该返回的地址。**nX-u8系列的做法是将该地址保留在**LR寄存器**中，当函数要返回时，**再将该寄存器的值赋值回PC寄存器即可**

然而，问题还是存在：如果存在多级函数调用怎么办？每次调用都会覆盖LR寄存器，这样的话只能保证最后一级的函数调用能够正常返回。


> 例如：P1调用P2,此时LR=P1调用的返回地址，然后P2调用P3，此时LR=P2调用的返回地址，当P3返回时，LR的值被赋值给PC寄存器，CPU从P2的返回地址开始执行，当P2返回到P1时，LR的值还是P2调用的返回地址（P1调用的返回地址在P2发生调用时被覆盖掉了），因此，P2函数永远无法返回

欲解决这个问题，我们可以选择将LR寄存器的值压入到**栈**中

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-ebd3ab2643a54e6f247946e127b4c740_b.jpg)  
栈，是一种**先进后出**的数据结构，什么先被**压入**，什么就后被**弹出**

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c7a43bad3dae8dde70a042137cdc5a3f_b.jpg)  
如图，大家应该可以猜到我们该怎么做了吧？

没错！在每个函数开始前PUSH LR，然后在返回时POP PC

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-b82c87ad91108a61d058df16ee68224b_b.jpg)  
如图，这样，我们只要**确保每次调用和返回都是成对出现**，我们的程序就可以自如地进行函数调用与返回。

聪明的你一定发现了，如果某一次，PUSH LR和POP PC**没有成对出现**，函数就无法正确地返回：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-2d75dff264ae169f0ecbc77368f05178_b.jpg)  
如图，如果进入函数P1时，跳过了PUSH LR 语句。当执行到POP PC 时，由于LR 没有事先被PUSH到栈中，POP PC时弹出的值不再时p1的返回地址，**而是栈里上一条数据**。当然，CPU**不会**帮你检查这个数据所代表的地址是什么，它**只会按照要求跳转到那里去执行**，因此，之后发生了什么我们无法预测，这取决于之前栈中的数据是什么。通常情况下，这个是候程序便崩溃了，因为栈通常还会用于存储一些其它的值，而这些数据可能并不属于任何一个地址，当CPU执行过去时，便会出错（例如，可能之前有程序将一张图片的地址压入了栈中，那么CPU跳转过去执行时，便会崩溃）

现在我们来想想，如果我们能够事先布局好堆栈里的数据，如图：

例如这里，我们压入两条我们自定义的地址（地址里可能是我们自己写的程序）

然后在函数调用时跳过PUSH LR（例如：原本的程序是CALL <addr:04>，但是我们让它执行CALL <addr:08>，正好跳过函数开头的PUSH LR）

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c0b6f5c19f2f7a7aec2a02b5655ff1ed_b.jpg)  
这样，当它执行到POP PC时，弹出的值不再是P1函数的返回地址，而是我们预先设计好的HACK P1，这样，CPU的指令就交到了我们手里。

**这，便是ROP的原理**



---

## 1. 如何在991CNX中触发ROP？  
这一步，已经有前人帮我们做好了。

[CASIO fx-ES PLUS calculators exploits](http://casiocalc.wikidot.com/exploits-of-classwiz-calculator-model)![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-6e2a1afc24930dcd76a0911fe91eedbb_b.jpg)  
外国的几位研究者，发现了这样一个漏洞：在an字符前输入一定长度的数据可以改变某些指针的位置

如图，他们发现：当an前有110个字符，按下【=】键后，计算器中存储**重做缓冲区（就是当你[AC]清屏后，按【←】键可以调出清屏前之前输入的内容）**的指针位置改变了。

我们都知道，每次你按下【=】号时，你所有输入的内容都会被复制到重做缓冲区，以便你不小心删除后可以按【←】键将记录调出来。但是，由于我们修改了存储该区域地址的某个数据的值，下一次执行复制时，数据将会被复制到一块新的地方，而不再是重做缓冲区。

经过他们的研究，发现：这些数据会被复制到栈下方的一块空间，大概是这样的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-465f3ae7e2897b6a81a28ff091607004_b.jpg)  
  


并且，**这个位置与栈顶正好相差<34个字节>**!

这也就意味着，如果你输入了34个字节的任意数据，然后再输入几个字节的数据，那么，**最后的那几个字节数据将会被覆盖到栈顶**，**即原本存储函数返回地址的地方**！（别忘了，这个复制功能本身也是由一个函数来（smart\_strcpy）实现的，所以它被调用时，肯定会先PUSH LR。并且，这个函数只实现了字符串的拷贝，不涉及其它对栈的操作，因此我们能够确定栈顶肯定保存的是返回的地址）

想象一下：当按下【=】的瞬间，一些数据被复制了，其中一部分数据覆盖到了栈中，只要我们能事先安排好这一部分数据，那么，当复制函数结束时，POP PC将会把我们安排好的那个地址放入PC寄存器中，此时，**CPU就会为我们工作！**



---

## 2. 函数、符号表、逆向汇编代码  
为了继续下去，我们必须知道由哪些地址我们可以利用，幸运的是，991cnx的ROM已经被人反编译出来了，并且破解了一部分的函数地址，相关内容在下方我的Github仓库中。当然，在他们研究的基础上，我进一步根据汇编程序，破解了另外一部分比较有用的函数地址，例如**按键检测，更方便的寄存器操作等等（后面细说）**

[fxesplus/991cnx at master · qiufuyu123/fxesplus](https://github.com/qiufuyu123/fxesplus/tree/master/991cnx)这是github仓库，fork自user202729，增加了一些新地址还有反编译的汇编结果

打开 **991cnx --> betterlabels.txt** 可以看到这里列举了一些常用地址，\_disas.txt 是真机ROM的汇编代码



---

## 3. 如何输入这些地址？  
在betterlabels文件中的地址，都是以16进制格式存在的，而CPU加载地址时，也必须是以字节码的形式加载，那如何把这些地址输入到计算器中呢？

我们都知道，计算器上显示的一个个文字，都是有它对应的**编码**的，计算器内部存储的只是这些编码，它们由单字节和双字节编码组成。这也意味着，只要我们输入的内容所对于的编码等于我们的地址（数据），当CPU执行时，就会把它们当作地址来处理。

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-e636b2bc4ae315835892fb5f2ef00fcf_b.jpg)  
具体字符表可以看这个贴子。

举个例子，我们想要输入16进制的值（地址）**2:20FE** 来显示字符串

首先，将其转换为小端字节序： FE 20 x2 xx (地址2byte对齐，因此为4字节，这里x表示任意）

也就是说，这个地址的16进制形式可以是 FE 20 32 20 (这里x可以带入任何）

然后我们去查表（FE开头的字符为双字节字符，去FE双字节字符表查表）,把16进制拆成两位，例如20--> '2' , '0',先在左侧的那一列找'2',然后再由上方那一行定位到'0'

得到如下： Pa>kgf/cm2 2 0 

至此，我们就可以输入了：SHIFT, 8, 下, 2, 6 (打出Pa>kgf/cm2), 2(打出数字2), 0(打出数字0)



---

## 4. 小小实践：  
查阅函数表，我们发现2:20FE接收er2的值作为字符串的地址，那如何给er2赋值呢？

一个简单的方法就是...

**我们不需要赋值**

通过查看smart\_strcpy源码（即当按下【=】时计算器执行 **复制到重做区** 的操作），我们发现，该函数会自动给er2赋值为**输入缓冲区的地址**

**意思就是：**

当在an溢出后，屏幕中输入：<34字节> FE 20 32 20 后按下【=】号，er2的值自动被复制为

 (-->这里！)<34字节> FE 20 32 20

由于一行为17个字符，那么可以知道，按下【=】号后，计算器会把前17个字节的数据，按照**二级字符表显示到屏幕上**

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-974833751216e19ce033ad518b12dbce_b.jpg)  
这是二级字符表

假设，此时我们想在屏幕上显示 "12345678901234567"

首先，查看二级字符表，找到对应的16进制编码，为：

31 32 33 34 35 ... ... ... 35 36 37

然后，要把这些字节输入到输入缓冲区的前17个字符中

查阅**一级字符表**，得到：

1 2 3 4 5 .... 7

(没错！二级字符表中123....90正好与一级字符表123...90相对应！）

我们先记一笔，待会儿我们要把这17个字符打到缓冲区中。

这样，我们就得到了要输入的全部内容：

< 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7><17bytes任意单字节字符> <Pa>kgf/cm2 2 0 >

我们就可以开始啦：

### a. 进入线性复数模式  
首先，进入【线性模式】：

[SHIFT][菜单][1][3]

进入【复数模式】

[菜单][2]

### b. 进入字符转换器  
[SHIFT][8][下][2][7][左][1][=][上][左]

### c. 刷'an'  
[SHIFT][.(小数点)][左][左][右][i(虚数i(ENG键))][左][9][DEL][DEL][右][右][DEL]

此时，屏幕上应该只有一个 `an` 符号

接着，光标移到`an`前，输入100个数字（可以用123456789来计数）

然后，输入`+` 号，继续输入`9` 个数字


> 你一定注意到了：  
> 我们要输入110个字节的数据，为什么不能直接再an前打110个数字呢？  
> 原因是：991cnx计算器不允许超过100位的大数字  
> 所以我们用+123456789 来代表剩下的那10个字节  
> 这样，<100bytes><1byte(`+`)><9bytes><an>正好在an前有110个字节的数据！

按下【=】

不出所料，按照之前所说的一样，屏幕清空了，此时某个指针位置已经被改变 。

### d. 输入我们之前安排好的数据  
打出`12345678901234567`,这一共17个字节，就是我们要显示的一行字符

打出任意17个单字节字符（随便在一级单字节字符表中寻找），**这里为了方便，我打了17个1**

至此，我们有了<34bytes>字节的数据，然后我们输入ROP的地址：FE 20 32 20

即打出Pa>kgf/cm2 2 0 

`SHIFT,8,下,2,6` `2` `0`

如果没有问题，你的输入区应该是这样的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-816210e2cba8430bd537ed51b6274675_b.jpg)  
 按下【=】号：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-a326f7d8352db6bbe49f0407f9be6455_b.jpg)  
### e. 发生了什么？  
按下【=】时，输入缓冲区被复制到栈下方的空间，第<34>个字节后正好覆盖掉栈顶，然后smart\_strcpy POP PC返回，由于栈被覆盖，返回地址被覆盖为：FE 20 32 20 ， CPU跳转到2:20FE执行

## 5. 小小实践2 ——二级跳转ROP链  
### a.准备  
刚刚我们只是简单的让cpu为我们执行了一次跳转，根据我们之前所讨论的内容，如果跳转后任然没有执行PUSH LR操作，那么这个函数返回时，又会在去将栈中下一条数据POP到PC中。利用此特性，我们可以做多级跳转：

POP PC --> <p0>跳转到<p1跳过PUSH LR的地址> --> POP PC --> 由于p1没有PUSH LR,所以返回的地址不是<p0>,而是栈中下一条数据。

举个例子，这里我们

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-6ac8e6abd26f99a43d3af08551c42476_b.jpg)  
选择**2:21AE ： 显示一行文字（不同于220FE，这个地址不会显示PRESS PC,并且可以控制显示行数）**

由于这个地址跳过了原函数(2:21BC)处的PUSH LR指令，所以当它返回时，会pop栈中下一条地址到pc中，只要我们安排好栈下一条地址，就能实现二级ROP跳转

我们来实现这个功能：**显示一行文字 --> 再显示一行文字**

首先查表2:21AE，这里不需要了，因为我已经整理出来了：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-3b2b38c96b8d99c086801b5402d156a8_b.jpg)  
这里还有一个问题：**2:21AE会根据r0寄存器的值设置显示的行数，我们在调用这个地址前需要先把r0寄存器赋值了才行。**

### b. 寄存器  
![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-5dd155002a490d099e55ccb575434e8b_b.jpg)  
这是u8芯片的寄存器，一共有16个寄存器（r0-15)，每个寄存器存储一字节数据

er0是双字节的，它对应着r0和r1，这意味着如果要对r0赋值，除了直接令r0为xxx以外，我们还可以赋值给er0寄存器的高字节（对应r0)，而它剩下的一个字节(对应r1)我们可以不管

xr0是四字节的，对应着r0,r1,r2,r3,理论上我们也可以对xr0赋值达到对r0赋值的目的，**但是，由于xr0包含了r2,r3,也就是er2寄存器（记得吗，er2存储着要显示的字符串的指针），我们不使用这种方法**

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-406eb0a2fae137d5cae08cf31633a96b_b.jpg)  
如图，1:21A8代表着pop er0，即将栈中的2个字节赋值给er0寄存器


> 为什么不选择一个地址，它能直接执行pop r0呢？  
> 当然，我们肯定能找到这么一个地址。  
> 但是，问题在于——这个地址是否包含特殊字符：例如，地址 1:769C是pop r0

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-f1cafcd7ec39e6e8b1bc1d99d835226b_b.jpg)  

> 但是我们暂时没法用它，因为9C在字符表中是一个`@` 的符号，即特殊字符，需要用特殊方法刷出，这里先不用 。

因此，我们选择**使用1:21A8地址，对应的字符为 \* e e (x)**

因为它执行的是pop er0，所以我们还要在栈后面安排2个bytes，分别代表r0 和 r1

这里，我们要在第一行显示，所以r0应该被赋值为0x0? (?表示任意值），由于行数看的是低8位，所以高8位不用管），0-3分别代表1-4行

假设，我们让r0赋值为0x01，我们去查表:

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-931d93fc824fbf8bca72abe1dfc0185c_b.jpg)  
**显然，这是一个特殊字符，我们没法直接输入**

**怎么办呢?**

**既然一级字符表不能满足我们的需求了，我们可以看看二级字符表：**

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-ba6d80b5f6c5b1818855a87355d69266_b.jpg)  
可以看到，双字节字符 `in>cm` 代表的编码是FE 01 ，而我们只想要保留01,怎么办呢？？？

回头再来看一下代表ROP地址的数据：

 ***1:21A8 -- > \* e e (x)***

可以看到，由于栈2bytes对齐，我们人为在地址的最后需要补上任意一个单字节字符(x)，如果我们把*in>cm*中的0xFE存到这个仅仅用于对齐的字节当中，然后01放到下一个字节中去，大概是这样的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-c8bab681ef6db46aa93e7eaf2b1ae9b3_b.jpg)  
可以看到，虽然输入了5个符号，但由于In>cm是双字节，其实对应的16进制数据还是6个字节

A8 21 21 FE --> pop er0 (0xFE为对齐用的字节，没有作用）

01 30 --> 栈中的数据，在pop er0执行时被弹出赋值给er0寄存器 --> r0: 01 r1: 30

通过这样的一步操作，**我们就巧妙的避开了0x01这个特殊字符**

### c. 开始输入  
老样子，先进入110an模式（线性复数模式刷an,an前110个字节）

先输入17个要显示的字符<1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7>

输入剩下17个字节< 1 1 1 1 ..... 1>

输入 [\*(乘号)] [e] [e] [in>cm (SHIFT 8 1 1)] [0]

然后输入下一条栈的值：

输入C (SHIFT,÷) , e(自然常数，ALPHA,x10x(小数点右边那个)) , 2 , x(右上方的`x`变量）


> 这里任意字符为啥要选用一个x变量？  
> 为了清屏。  
> 我们注意到之前那次实践按下【=】号后由于没有执行清屏，内容非常乱  
> 计算器有个特性：当输入的算是含有任何一个变量时，  
> 按下CALC再按下[=]，计算器会先清屏， 然后再执行后续操作  
> 理论上你输入的内容里只要有一个变量（x,y,A,B,C,D,E,F,M)即可  
> 你可以选择把它放在一个不重要的地方，比如在剩下的17个字节中插入一个，或者在地址最后一位插入（地址2字节对齐，最后一个字节仅仅为了对齐），这里我选择后者。

然后输入再下一条栈的值：


> Pa>kgf/cm2 2 0

一切输入正确，屏幕应该是这样的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-a34511ccc623048dec95ae97c053e37e_b.jpg)  
先按下`CALC`(左上角的键)，再按【=】号 

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-41296a98da44152eae5c20441a65257e_b.jpg)  
有没有发现什么奇怪的地方？

**没错！调用第二次打印函数时，内容不再是我们一开始输入的前17bytes数据了，而是之后的17bytes。**

**这说明在执行文本显示时，er2寄存器的值会自动往后移17个字节！**



---

### d. 不同显示文本的函数的区别  
**相信你有个疑问，为什么同样是显示文本，我们一次用了2:20FE，另一次用了2:21AE?**

**其实，这些不同的文本显示函数是有细微差别的*:***

对于2:20FE：

他会调用两次2:21AE，一次显示er2的内容，一次显示PRESS AC，然后等待用户按键输入，然后死机

对于2:21AE:

它仅仅在屏幕上显示内容，**不会死机，而是会继续POP PC返回！**

**发现问题了吗？**

**没错！**如果我们最后一次调用的时2:21AE函数，它仍然会执行POP PC返回，但是，由于我们没有在栈中继续安排其他的地址，**它便会强行从栈中取值返回**，返回去了哪？我们也不知道，**但大概率计算器会死机**.

所以，我们尽量确保ROP链的最后一个地址是一个用不返回的地址。

那有没有仅仅在屏幕上显示文字，不显示PRESS AC，然后死机（不返回）的函数呢？答案是有的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-f18c3de0153c7b84e34790c3fa5eae5f_b.jpg)  
2:20FE

由于FE仍然是特殊符号无法打出，我们把它和20合到一起(FE 20)，查询双字节字符表，得到`mti`符号（SHIFT,7,3,x,这里x表示x变量的那个按键）

2:205C --> 5C20x2xx(小端字节序) -->FE 5C x2 xx--> mti 2 (x)

### e. 尝试更好地显示字符：  
这次，我们利用2:20FE函数来显示字符：

老样子，进110an模式

我们来点英文字母：

通过查二级字符表表得知，字母A的编码为0x41，对应一级字符表的`Ans`字符，空格符号的编码为0x20，对应一级字符表的`i`(虚数i)字符

输入前17字节数据：

Ans i i i i i i i ... i(16个i)

后17字节数据：

11111111...111(17个任意单字节字符，这里我用了1)

然后【DEL】删除最后的一个i


> 和之前处理pop er0 函数一样，双字节符号mti(FE 5C)，我们不需要它的FE这个字节，所以将它前一个字节放到前<34bytes>中，后一个字节放在<34bytes>后，即POP PC的值

打出mti(SHIFT,7,3,X),2,x(变量x的作用仍然是清屏）

应该是这样的：

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-743cb5a69742d19d4ea89d3c2f53bf70_b.jpg)  
按下【CALC】【=】

![]((20240419)fx-991cnx计算器利用ROP漏洞执行任意代码_Qesole/v2-7ff778f8c7c0fffdb8a43bcaeca3d580_b.jpg)  
## 6. 结尾  
恭喜你，如果你理解并实践了上文所有的内容，那么，你已经对于ROP技术有了一定的了解。

当然，还有许多东西在本文中没有提到——要实现开头视频的效果，还要涉及一些其他的东西：例如特殊字符的刷法、更大的输入区(不再是前34bytes)。

这些内容将在**下一篇文章**中提到，敬请期待！

## 7. 进阶篇更新啦！  
[Qesole：【进阶篇】fx-991cnx计算器:利用ROP漏洞执行任意代码](https://zhuanlan.zhihu.com/p/620584634)## 7. 资料 & 参考  
### 本文涉及的所有资料都位于我的github仓库：  
[fxesplus/991cnx at master · qiufuyu123/fxesplus (github.com)](https://github.com/qiufuyu123/fxesplus/tree/master/991cnx)  


### 致谢/参考  
**[0] fx-es吧（故事的开始）**

[fx-es(ms)吧-百度贴吧--计算器爱好者的专业社区--提倡使用正版计算器！跟进各大品牌计算器相关的最新资讯；发布国内外不同型号的计算器测评；研究和讨论各大品牌正版函数科学计算器的异常、爆机、拼字等以](https://tieba.baidu.com/f?kw=fx-es(ms)&ie=utf-8)[1] Casio外国论坛

[https://community.casiocalc.org/](https://community.casiocalc.org/)

[http://casiocalc.wikidot.com/](http://casiocalc.wikidot.com/)

[2] user202729的github主页

[https://github.com/user202729/fxesplus](https://github.com/user202729/fxesplus)

