# CPU的工作原理
假设有个小学生，正在照着数学书，在草稿纸上练习竖式乘法。从某种程度上来说，他就像是一个正在工作的CPU。*ROM*（Read-Only Memory，只读存储器）就是他面前的数学书（上面写着他正在运行的程序）以及他铅笔盒里贴着的乘法表（也就是程序运行所需要的数据）。两者的共同特点是，它们都只能读取，不能修改；不论程序的输入是什么，它们都是固定不变的。*RAM*（Random Access Memory，随机存储器，通称内存）就是他手上的草稿纸，纸上写着程序产生的一些数据。它的特点是，可以读也可以写，而且能够存储大量的数据。但是，他不能直接操作RAM上的数据，而必须通过眼睛读数，用手写数。*CPU*就是他自己。CPU可以根据ROM上的指令做一些操作，也可以从ROM或RAM中读取数据，还能向RAM里写入数据。除此之外，CPU还有一组寄存器，可以临时记住一些数据，但是存储量很有限。CPU的运算都只能用寄存器里的数据，要想接触内存，必须先从内存读入，计算完以后再写入到内存中去。

卡西欧的CLASSWIZ计算器（包括一代和二代）都使用了nX-U16/100微控制器（下称nX-U16）。因此，一代和二代的汇编语法是一样的。

nX-U16有16字节的通用寄存器。通用寄存器，就是说没有特殊的功能，可以随意使用。这些寄存器分别编号为R0，R1，……，R15。相邻的两个通用寄存器组合在一起，就拼出了一组两字节长的寄存器：ER0，ER2，……，ER14。其中ER12又叫BP，ER14又叫FP。也可以四个四个一拼，组成XR0、XR4、XR8、XR12。还能八个八个一拼，组成QR0和QR8。寄存器组合的时候，数据的高位存在编号大的寄存器里，低位存在编号小的寄存器里。比如，如果ER0=0xDEAD，那么R0=0xAD，R1=0xDE。通用寄存器以外，还有一些控制寄存器，具有特殊的功能，这些等我们碰到了再讲。

接下来是一些常用的指令。学会这些指令，就能看懂大多数代码了。
# 常用指令
## `MOV`和`ADD`
`MOV a, b`表示“令a=b”，其中a必须是寄存器，b可以是一个数，也可以是寄存器。比如，`MOV R0, 0x13`表示把0x13赋给寄存器R0；`MOV ER2, ER0`表示把ER0的数值赋给ER2。`ADD a, b`表示“令a=a+b”。它的语法和MOV相同。接下来看一个例子。下面的程序运行完后，R0和R1分别等于几呢？
```
MOV R0, 0
MOV R1, 1
ADD R0, R1
ADD R1, 1
ADD R0, R1
ADD R1, 1
```
答案：R0=3，R1=2。
## `CMP`与寄存器PSW
PSW是一个控制寄存器，长一字节。它还被进一步拆成许多个flag。在运算之后，有些flag的值就会根据运算结果而更新。
* CF表示加法中的进位（Carry），同时也表示减法中的借位。如果运算产生进位或借位，CF=1。
* ZF表示零（Zero）。如果结果是零，ZF=1。
* SF表示符号（Sign）。一个二进制的数值，既可以表示非负整数，也可以表示有符号整数。有符号整数的最高位表示符号位，如果符号位是0，那数值就和非负的一样，如果符号位是1，就把这个数减去256。例如，二进制数01100001，不管解释成非负整数还是有符号整数，都是97。而11100001解释成非负整数是225，解释成有符号整数就是225-256=-31。SF追踪运算结果的符号位。
* OVF表示有符号进位（Overflow）。它的运算规则较复杂。
* MIE和中断相关，一般用不到。
* HCF表示半进位（Half-Carry），一般用不到。
* ELEVEL表示异常等级，一般用不到。

`CMP a, b`表示“比较a和b，结果存入PSW寄存器”。比较的结果，就是像大于、等于这样的。实际上，CMP内部做了一次减法。因此a等于b就是ZF=1，a小于b就是CF=1。其实，MOV和ADD也会更改PSW，MOV只更新ZF和SF，而ADD还会更新CF、OVF、HCF，规则就是上面那些。
## `B`和`BC`与寄存器PC
PC是一个控制寄存器，长2.5字节（20个二进制位）。它指向CPU要执行的下一条指令。CPU工作时，会从PC指向的地方取一条指令，然后根据指令的长度，自动把PC+2或+4，让它指向下一条指令，接下来再执行那条指令。如果不去修改PC的值，CPU就会按照顺序一条一条执行下去。如果有一条指令可以修改PC的值，CPU就会跳转到别的地方去。`B xxx`表示把“PC设为xxx”。比如，`B 0x093FE`表示跳转到093FE这个地方。还有一种条件跳转。`BC cond, xxx`表示“如果满足条件cond，就跳转到xxx”。这条指令常常与CMP连用。其中，条件cond有这些：
* AL表示无条件。从功能上看，`BC AL, xxx`和`B xxx`是基本相同的。
* EQ表示等于（也就是ZF=1）。
* NE表示不等于（也就是ZF=0）。
* LT表示小于（也就是CF=1）。
* GE表示大于等于（也就是CF=0）。
* LE表示小于等于（也就是CF=1或ZF=1）。
* GT表示大于（也就是CF=0且ZF=0）。
* 还有GES、GTS、LES、LTS、PS、NS、NV、OV。它们用得较少，具体规则可以查阅操作手册，这里就不展开了。

接下来看一个例子。下面的程序意思是，如果R0在[0x20, 0x40)中，就赋值R1=1，否则，R1=0。
```
10000  CMP R0, 0x20
10002  BC LT, 1000C
10004  CMP R0, 0x40
10006  BC GE, 1000C
10008  MOV R1, 1
1000A  BC AL, 1000E
1000C  MOV R1, 0
```
再看一个例子。下面的程序运行完后，R0=1加到10的和=55。
```
10000  MOV R0, 0
10002  MOV R1, 1
10004  ADD R0, R1
10006  ADD R1, 1
10008  CMP R1, 10
1000A  BC LE, 10004
```
## `L`和`ST`
L和ST负责对内存的读写。`L a, p`表示从内存中位置为p的地方读取数据并赋给a。其中a是寄存器，p可以是寄存器，也可以是数值。比如，`L R0, D155`表示从D155这里读取一个字节赋给R0，`L ER2, [ER0]`表示从ER0指向的地方读取两个字节赋给ER2。ST的语法和L相同，功能正好相反，ST表示向内存写入。接下来看一个来自计算器ROM的实际例子。
```
0D076  MOV ER10, ER2
0D078  MOV ER12, ER0
0D07A  L R0, [ER10]
0D07C  ST R0, [ER12]
0D07E  ADD ER10, 1
0D080  ADD ER12, 1
0D082  MOV R0, R0
0D084  BC NE, 0D07A
```
它的功能是，从ER2指向的地方复制一些数据到ER0指向的地方，如果读到0，就结束复制。（你应该记得，字符串是以NUL结尾的，因此这里其实就是复制了一个字符串。）注意0D082处的指令`MOV R0, R0`看起来没有用，但是，刚才说过，MOV指令也会更新ZF，因此这里如果R0是0，ZF就设为1，否则，ZF设为0。下一条指令`BC NE, 0D07A`在这里意思就是“如果R0不是0，就跳转到0D07A”。
## `BL`和`RT`与寄存器LR
> 函数A要调用函数B，然后函数B返回到函数A继续执行，这是如何实现的？

第一步，肯定是直接跳转到那个函数的开始的地址，也就是B指令。但是，如果直接这么操作，会有问题——程序无法返回了。

为了解决这个问题，nX-U16提供了两条指令。`BL xxx`表示“把下一条指令的地址（也就是函数调用完，应该返回的地址）保存进寄存器LR，然后跳转到xxx”。LR和PC一样，是2.5字节长的控制寄存器。它的功能就是备份PC。当函数要返回时，`RT`表示“把LR赋给PC，也就是跳转回LR指向的那条指令”。

假设刚才那段程序后面是`0D086  RT`。那它就成了一个可以返回的函数。看这段代码：
```
MOV R0, 0x80
MOV R1, 0xD1 ; 其实nX-U8不支持MOV ER0, 0xD180这样的指令，所以只能分开来写了
MOV R2, 0x48
MOV R3, 0xD2
BL 0D076
```
这段代码调用了函数0D076。根据刚才提到0D076的功能，我们发现，这段代码可以从0xD248这里复制一个字符串到0xD180。结合以前学过的知识，0xD180是计算器的输入区，而0xD248是回放区。调用回放的时候就会做这么一次复制。所以我们已经帮卡西欧实现了一个功能！
## `PUSH`和`POP`与寄存器SP
### 栈的原理
如果某个函数需要保存一些数据，当然可以通过寄存器，但是一旦数据多起来，寄存器就不够用了，必定要存到内存里。但是内存是所有函数共用的，如果随便找个地方就存了，可能会影响到别的函数。聪明的计算机科学家想到一个办法。他们创造了一种数据结构叫做“栈”，直观来说可以理解成一叠纸。每调用一个函数，这个函数就在栈上加一张纸，它的全部数据都保存在这张纸上，当它退出时，就把这张纸拿掉，这样调用它的函数就能不受干扰地继续工作了。只要每个函数都只操作自己的这张纸，而且退出时拿掉自己的纸，数据就不会乱套。而且，可以发现程序运行时，永远在操作最上面的这张纸，编程的时候很方便。可是内存空间是连续的，一叠纸很明显有个“最上面这张”，内存却没有。因此CPU里有个寄存器SP（长度2字节），用来保存栈顶的位置。另外，L和ST在栈上不太方便（因为存数的时候不仅要存，还要改变SP的位置），因此CPU有两条新的指令，PUSH和POP。`PUSH r`表示“先把SP减去r的长度，然后把r存到SP指向的地方”，其中r是寄存器。`POP r`正好相反，表示“先把SP指向的数据赋给r，再把SP加上r的长度”。看这段代码：
```
MOV R0, 0x80
MOV R1, 0xD1
MOV R2, 0x48
MOV R3, 0xD2
PUSH ER0
PUSH ER2
POP ER0
POP ER2
```
运行的时候，一开始栈是空的：`... 00 00 00 00 00 00[xx]xx ...`，其中方括号表示SP指向的地方，xx表示上一个函数的栈。
在`PUSH ER0`时，由于ER0是两字节长，因此SP先会减去2，变为`... 00 00 00 00[00]00 xx xx ...`，然后把ER0的值存到栈上，就是`... 00 00 00 00[80]D1 xx xx ...`。
同理，`PUSH ER2`后，栈变为`... 00 00[48]D2 80 D1 xx xx ...`。
接下来`POP ER0`把栈上的数值0xD248赋给ER0，然后SP+2，变为`... 00 00 48 D2[80]D1 xx xx ...`。
同理，`POP ER2`后，ER2变为0xD180，栈变为`... 00 00 48 D2 80 D1[xx]xx ...`。栈的情况恰好和原来相同。可是ER0和ER2的值交换了。这说明，在栈上保存数据时，先进栈的数据要后出栈，这样才能保持数据顺序不变。

注意，nX-U8的栈是两字节对齐的，如果出入栈的数据不到两字节，就会补成两字节，如`POP R0`实际上SP+2，`PUSH LR`实际上SP-4。
### 栈的应用
刚才0D076的代码中用到了ER10和ER12两个寄存器。如果调用它的函数正好在这两个寄存器里存了数，这些数就没了。卡西欧编译器遵循一个规则：任何函数不应改变R4以后的寄存器的值。这样，这些寄存器对于函数调用来说就是安全的。那怎么做到不改变呢？就需要通过栈。这个函数的完整代码是：
```
0D070  PUSH XR8
0D072  PUSH ER12
0D074  MOV ER8, ER0
0D076  MOV ER10, ER2
0D078  MOV ER12, ER0
0D07A  L R0, [ER10]
0D07C  ST R0, [ER12]
0D07E  ADD ER10, 1
0D080  ADD ER12, 1
0D082  MOV R0, R0
0D084  BC NE, 0D07A
0D086  MOV ER0, ER8
0D088  POP ER12
0D08A  POP XR8
0D08C  RT
```
我们看到，这个函数用栈备份了ER8、ER10、ER12的值，返回时又恢复了这些值。

函数返回看的是LR里存的返回地址。这个方法对一层函数调用是有效的。可是如果存在多级函数调用怎么办？每次调用都会覆盖LR寄存器，这样的话只能保证最后一级的函数调用能够正常返回。
> 例如：P1调用P2,此时LR=P1调用的返回地址，然后P2调用P3，此时LR=P2调用的返回地址，当P3返回时，LR的值被赋值给PC寄存器，CPU从P2的返回地址开始执行，当P2返回到P1时，LR的值还是P2调用的返回地址（P1调用的返回地址在P2发生调用时被覆盖掉了），因此，P2函数永远无法返回

这时就需要备份LR。在函数的开头加一句`PUSH LR`，结尾处把`RT`换成`POP PC`，只要确保所有的PUSH和POP全都配对，就可以任意调用函数了。
## 寄存器EA
对于大量数据的存取，CPU提供了一个EA寄存器，长度两字节。和一般的寄存器不同，L和ST对EA还有一个特殊的语法。`L r, [EA]`和一般的L指令没什么区别。`L r, [EA+]`表示，在读取完以后，还要让EA加上读取的长度，也就是自动指向下一个数据。同理，对于ST也有一样的语法。另外，EA可以用`LEA`指令直接赋值。例如`LEA [F800]`就表示把EA设为0xF800。
## `RB`、`SB`、`TB`
这三条指令用来按bit操作数值。`TB a.x`表示检测a的第x个二进制位，并按照结果设置ZF。其中，最低位是0，最高位是7。a可以是寄存器，也可以是内存地址。RB和SB语法相同，RB表示把这一位设为0，SB表示把这一位设为1。
